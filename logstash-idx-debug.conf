input {
   stdin {
     type => "syslog"
   }
#  file {
#    type => "syslog"
#    path => ["/Users/james/workspace/logstash/samples/*.log"]
#    sincedb_path => "/dev/null"
#    start_position => "beginning"
#  }
}


filter {
  if [type] == "syslog" {

    # timestamp added by rsyslog
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:ts}%{SPACE}%{GREEDYDATA:message}" }
      overwrite => [ "message" ]
      tag_on_failure => ["_grokparsefailure", "_timefail"]
    }
    date {
      match => [ "ts" , "ISO8601" ]
      remove_field => "ts"
    }

    # hostname added by rsyslog
    grok {
      match => { "message" => "%{HOST:host}%{SPACE}%{GREEDYDATA:message}" }
      overwrite => [ "message", "host" ]
    }
    dns {
      # *Add* the DNS name to the 'host' attribute.
      resolve => [ "host" ]
    }
    unique {
      # DNS will return the IP if the hostname isn't resolved, leaving tow IPs on the 'host' field.
      fields => [ "host" ]
    }

    # Mark as unparsed until we know something is parsed
    noop {
      add_tag => "_unparsed"
    }

    # ASA firewall hit message.
    # Broken apart for readability.
    if [message] =~ /^%ASA-5-106100: access-list/ {
      grok { match => { "message" => "%ASA-5-106100: access-list %{NOTSPACE:[fw][acl]} %{WORD:[fw][action]} %{WORD:[fw][protocol]}" } }
      grok { match => { "message" => "%{NOTSPACE:[src][int]}/%{IPORHOST:[src][host]}\(%{INT:[src][port]}\) -> %{NOTSPACE:[dst][int]}/%{IPORHOST:[dst][host]}\(%{INT:[dst][port]}\)" } }
      grok { match => { "message" => "hit-cnt %{INT:[fw][hits]} (first hit|.*-second interval) \[%{NOTSPACE:[fw][ace]}, %{NOTSPACE:[fw][ace_exp]}\]" } }
      noop {
        add_tag => "firewall"
        remove_tag => "_unparsed"
      }
    }

    # DHCPACK
    if [message] =~ /DHCPACK on/ {
      grok {
        match => { "message" => "DHCPACK on %{IP:[dhcp][ip]} to %{COMMONMAC:[dhcp][mac]}" }
        add_field => { "[dhcp][type]" => "DHCPACK" }
        add_tag => "dhcp"
        remove_tag => "_unparsed"
      }
      if [message] =~ /\([^)]\) via / {
        grok {
          match => { "message" => "\((?<dhcp_hostname>[^)]*)\) via " }
        }
      }
    }

    # DHCPACK [alternate form]
    if [message] =~ /DHCPACK to/ {
      grok {
        match => { "message" => "DHCPACK to %{IP:[dhcp][ip]} \(%{COMMONMAC:[dhcp][mac]}\)" }
        add_field => { "[dhcp][type]" => "DHCPACK" }
        add_tag => "dhcp"
        remove_tag => "_unparsed"
      }
    }

    # DHCPREQUEST [
    if [message] =~ /DHCPREQUEST/ {
      grok { match => { "message" => "DHCPREQUEST for %{IP:[dhcp][ip]}" } }
      grok { match => { "message" => "from %{COMMONMAC:[dhcp][mac]}" } }
      if [message] =~ /\([^)]\) via / {
        grok {
          match => { "message" => "\((?<dhcp_hostname>[^)]*)\) via " }
        }
      }
      noop {
        add_field => { "[dhcp][type]" => "DHCPREQUEST" }
        add_tag => "dhcp"
        remove_tag => "_unparsed"
      }
    }

    # DHCPINFORM
    if [message] =~ /DHCPINFORM/ {
      grok {
        match => { "message" => "DHCPINFORM from %{IP:[dhcp][ip]}" }
        add_field => { "[dhcp][type]" => "DHCPINFORM" }
        add_tag => "dhcp"
        remove_tag => "_unparsed"
      }
    }
    
    # DHCPDISCOVER
    if [message] =~ /DHCPDISCOVER/ {
      grok { match => { "message" => "DHCPDISCOVER from %{COMMONMAC:[dhcp][mac]}" } }
      if [message] =~ /\([^)]\) via / {
        grok { match => { "message" => "\((?<dhcp_hostname>[^)]*)\) via " } }
      }
      noop {
        add_field => { "[dhcp][type]" => "DHCPDISCOVER" }
        add_tag => "dhcp"
        remove_tag => "_unparsed"
      }
    }

    # DHCPOFFER
    if [message] =~ /DHCPOFFER/ {
      grok { match => { "message" => "DHCPOFFER on %{IP:[dhcp][ip]} to %{COMMONMAC:[dhcp][mac]}" } }
      if [message] =~ /\([^)]\) via / {
        grok { match => { "message" => "\((?<dhcp_hostname>[^)]*)\) via " } }
      }
      noop {
        add_field => { "[dhcp][type]" => "DHCPOFFER" }
        add_tag => "dhcp"
        remove_tag => "_unparsed"
      }
    }

    # Next thing here
  }
}

output {
  stdout {
    debug => true
  }
}
