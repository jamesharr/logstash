input {
   stdin {
     type => "syslog"
   }
#  file {
#    type => "syslog"
#    path => ["/Users/james/workspace/logstash/samples/*.log"]
#    sincedb_path => "/dev/null"
#    start_position => "beginning"
#  }
}


filter {
  if [type] == "syslog" {

    # timestamp added by rsyslog
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:ts}%{SPACE}%{GREEDYDATA:message}" }
      overwrite => [ "message" ]
      tag_on_failure => ["_grokparsefailure", "_timefail"]
    }
    date {
      match => [ "ts" , "ISO8601" ]
      remove_field => "ts"
    }

    # hostname added by rsyslog
    grok {
      match => { "message" => "%{HOST:host}%{SPACE}%{GREEDYDATA:message}" }
      overwrite => [ "message", "host" ]
    }
    #dns {
    #  # *Add* the DNS name to the 'host' attribute.
    #  resolve => [ "host" ]
    #}
    #unique {
    #  # DNS will return the IP if the hostname isn't resolved, leaving tow IPs on the 'host' field.
    #  fields => [ "host" ]
    #}

    # Mark as unparsed until we know something is parsed
    mutate {
      add_tag => "_unparsed"
    }

    # ASA firewall hit message.
    # Broken apart for readability.
    if [message] =~ /^%ASA-.-10610[023]: access-list/ {
      grok {
        match => { "message" => "%ASA-.-10610[023]: access-list %{NOTSPACE:[fw][acl]} %{WORD:[fw][action]} %{WORD:[fw][protocol]}" }
      }
      # user name for 106102 and 106103, can be '<unknown>'
      grok {
        match => { "message" => "for user '%{NOTSPACE:[fw][user]}'" }
        tag_on_failure => []
      }
      grok { match => { "message" => "%{NOTSPACE:[src][int]}/%{IPORHOST:[src][host]}\(%{INT:[src][port]}\) -> %{NOTSPACE:[dst][int]}/%{IPORHOST:[dst][host]}\(%{INT:[dst][port]}\)" } }
      grok { match => { "message" => "hit-cnt %{INT:[fw][hits]} (first hit|.*-second interval)" } }
      grok { match => { "message" => "\[%{NOTSPACE:[fw][ace]}, %{NOTSPACE:[fw][ace_exp]}\]" } }
      mutate {
        add_tag => "firewall"
        remove_tag => "_unparsed"
      }
      geoip {
        source => "[src][host]"
        target => "[src][geoip]"
      }
      geoip {
        source => "[dst][host]"
        target => "[dst][geoip]"
      }
    }

    # Messages from DHCP server
    if [message] =~ /DHCP[^ ]+/ {
      mutate {
        add_tag => [ "dhcp" ]
        remove_tag => "_unparsed"
      }
      grok {
        match => { "message" => "(?<dhcp_type>DHCP[^ ]+) " }
      }
      grok {
        # 'DHCPACK on IP', 'DHCPREQUEST for IP', 'DHCPINFORM from IP'
        match => { "message" => "(on|for|from) %{IP:[dhcp][ip]}" }
        tag_on_failure => []
      }
      grok {
        # 'DHCPACK on X to MAC', 'DHCPREQUEST for IP from MAC'
        match => { "message" => "(to|from) %{COMMONMAC:[dhcp][mac]}" }
        tag_on_failure => []
      }

      grok {
        # 'DHCPACK to IP (M:A:C)' [rare]
        match => { "message" => "to %{IP:[dhcp][ip]} \(%{COMMONMAC:[dhcp][mac]}\)" }
        tag_on_failure => []
      }

      grok {
        # 'M:A:C (HOSTNAME) via '
        # MAC is needed to prevent a double-match on 'DHCPACK to IP (MAC) via X'.
        match => { "message" => "%{COMMONMAC} \((?<dhcp_hostname>[^)]*)\) via " }
        tag_on_failure => []
      }

      grok {
        # 'via ethX relay IP_OF_RELAY'
        match => { "message" => "via ([^ ]+) relay %{IP:[dhcp][relay]}" }
        tag_on_failure => []
      }
      
      grok {
        # 'via IP_OF_RELAY'
        match => { "message" => "via %{IP:[dhcp][relay]}" }
        tag_on_failure => []
      }

      grok {
        # 'lease-duration 1234'
        match => { "message" => "lease-duration %{NONNEGINT:[dhcp][lease-duration]}" }
        tag_on_failure => []
      }

      mutate {
        rename => {
          'dhcp_type' => '[dhcp][type]'
          'dhcp_hostname' => '[dhcp][hostname]'
        }
      }

    }

    # Next thing here
  }
}

output {
  stdout {
    debug => true
  }
}
